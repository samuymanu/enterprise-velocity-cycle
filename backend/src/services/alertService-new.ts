import { PrismaClient, AlertType, AlertPriority, ProductStatus } from '@prisma/client';
import logger from '../logger';

const prisma = new PrismaClient();

export interface CreateAlertData {
  productId?: string;
  type: AlertType;
  priority: AlertPriority;
  title: string;
  message: string;
  threshold?: number;
  currentValue?: number;
  metadata?: any;
}

export interface AlertFilters {
  type?: AlertType;
  priority?: AlertPriority;
  productId?: string;
  isActive?: boolean;
  limit?: number;
  offset?: number;
}

export interface AlertWithProduct {
  id: string;
  productId: string | null;
  type: AlertType;
  priority: AlertPriority;
  title: string;
  message: string;
  threshold: number | null;
  currentValue: number | null;
  isActive: boolean;
  resolvedAt: Date | null;
  resolvedBy: string | null;
  metadata: any;
  createdAt: Date;
  updatedAt: Date;
  product?: {
    id: string;
    sku: string;
    name: string;
    stock: number;
    minStock: number;
    maxStock: number | null;
  } | null;
}

export class AlertService {
  private readonly ALERT_CLEANUP_DAYS = 30;

  /**
   * Revisa los niveles de stock de todos los productos activos
   */
  async checkStockLevels(): Promise<void> {
    const startTime = Date.now();
    logger.info('üîç Starting stock level check...');

    try {
      const products = await prisma.product.findMany({
        where: {
          status: ProductStatus.ACTIVE,
        },
        select: {
          id: true,
          sku: true,
          name: true,
          stock: true,
          minStock: true,
          maxStock: true,
        },
      });

      logger.info(`üìä Checking stock levels for ${products.length} products`);

      const alertsCreated = [];

      for (const product of products) {
        const alerts = await this.analyzeProductStock(product);
        alertsCreated.push(...alerts);
      }

      const duration = Date.now() - startTime;
      logger.info(`‚úÖ Stock level check completed in ${duration}ms. Created ${alertsCreated.length} alerts.`);
      
      // Actualizar m√©tricas de rendimiento
      await this.updatePerformanceMetrics(duration, products.length, alertsCreated.length);

    } catch (error) {
      logger.error('‚ùå Error checking stock levels:', error);
      throw error;
    }
  }

  /**
   * Analiza el stock de un producto espec√≠fico
   */
  private async analyzeProductStock(product: any): Promise<string[]> {
    const alertsCreated = [];

    try {
      // Verificar alertas activas existentes
      const existingAlerts = await prisma.alert.findMany({
        where: {
          productId: product.id,
          isActive: true,
          type: { in: [AlertType.LOW_STOCK, AlertType.OUT_OF_STOCK, AlertType.OVERSTOCK] },
        },
      });

      const hasLowStockAlert = existingAlerts.some(a => a.type === AlertType.LOW_STOCK);
      const hasOutOfStockAlert = existingAlerts.some(a => a.type === AlertType.OUT_OF_STOCK);
      const hasOverstockAlert = existingAlerts.some(a => a.type === AlertType.OVERSTOCK);

      // 1. Verificar stock agotado (prioridad m√°s alta)
      if (product.stock === 0 && !hasOutOfStockAlert) {
        const alertId = await this.createAlert({
          productId: product.id,
          type: AlertType.OUT_OF_STOCK,
          priority: AlertPriority.CRITICAL,
          title: `Stock Agotado - ${product.name}`,
          message: `El producto ${product.sku} se ha agotado completamente`,
          threshold: 0,
          currentValue: product.stock,
          metadata: {
            productSku: product.sku,
            autoGenerated: true,
            checkTimestamp: new Date().toISOString(),
          },
        });
        alertsCreated.push(alertId);

        // Resolver alerta de stock bajo si exist√≠a
        if (hasLowStockAlert) {
          const lowStockAlert = existingAlerts.find(a => a.type === AlertType.LOW_STOCK);
          if (lowStockAlert) {
            await this.resolveAlert(lowStockAlert.id, 'SYSTEM_AUTO_RESOLVE');
          }
        }
      }
      // 2. Verificar stock bajo
      else if (product.stock > 0 && product.stock <= product.minStock && !hasLowStockAlert && !hasOutOfStockAlert) {
        const priority = product.stock <= product.minStock * 0.5 ? AlertPriority.HIGH : AlertPriority.MEDIUM;
        
        const alertId = await this.createAlert({
          productId: product.id,
          type: AlertType.LOW_STOCK,
          priority,
          title: `Stock Bajo - ${product.name}`,
          message: `El producto ${product.sku} tiene stock bajo (${product.stock} unidades, m√≠nimo: ${product.minStock})`,
          threshold: product.minStock,
          currentValue: product.stock,
          metadata: {
            productSku: product.sku,
            autoGenerated: true,
            stockPercentage: Math.round((product.stock / product.minStock) * 100),
            checkTimestamp: new Date().toISOString(),
          },
        });
        alertsCreated.push(alertId);
      }
      // 3. Verificar sobrestock
      else if (product.maxStock && product.stock >= product.maxStock && !hasOverstockAlert) {
        const alertId = await this.createAlert({
          productId: product.id,
          type: AlertType.OVERSTOCK,
          priority: AlertPriority.LOW,
          title: `Sobrestock - ${product.name}`,
          message: `El producto ${product.sku} tiene sobrestock (${product.stock} unidades, m√°ximo: ${product.maxStock})`,
          threshold: product.maxStock,
          currentValue: product.stock,
          metadata: {
            productSku: product.sku,
            autoGenerated: true,
            overstockPercentage: Math.round((product.stock / product.maxStock) * 100),
            checkTimestamp: new Date().toISOString(),
          },
        });
        alertsCreated.push(alertId);
      }
      // 4. Resolver alertas que ya no aplican
      else {
        for (const alert of existingAlerts) {
          if (
            (alert.type === AlertType.OUT_OF_STOCK && product.stock > 0) ||
            (alert.type === AlertType.LOW_STOCK && product.stock > product.minStock) ||
            (alert.type === AlertType.OVERSTOCK && (!product.maxStock || product.stock < product.maxStock))
          ) {
            await this.resolveAlert(alert.id, 'SYSTEM_AUTO_RESOLVE');
          }
        }
      }

    } catch (error) {
      logger.error(`‚ùå Error analyzing stock for product ${product.sku}:`, error);
    }

    return alertsCreated;
  }

  /**
   * Crea una nueva alerta
   */
  async createAlert(alertData: CreateAlertData): Promise<string> {
    try {
      const alert = await prisma.alert.create({
        data: {
          productId: alertData.productId,
          type: alertData.type,
          priority: alertData.priority,
          title: alertData.title,
          message: alertData.message,
          threshold: alertData.threshold,
          currentValue: alertData.currentValue,
          metadata: alertData.metadata,
        },
      });

      logger.info(`üö® Alert created: ${alert.id} - ${alert.title}`);
      return alert.id;
    } catch (error) {
      logger.error('‚ùå Error creating alert:', error);
      throw error;
    }
  }

  /**
   * Obtiene alertas activas con filtros opcionales
   */
  async getActiveAlerts(filters: AlertFilters = {}): Promise<AlertWithProduct[]> {
    try {
      const where: any = {
        isActive: filters.isActive ?? true,
      };

      if (filters.type) where.type = filters.type;
      if (filters.priority) where.priority = filters.priority;
      if (filters.productId) where.productId = filters.productId;

      const alerts = await prisma.alert.findMany({
        where,
        include: {
          product: {
            select: {
              id: true,
              sku: true,
              name: true,
              stock: true,
              minStock: true,
              maxStock: true,
            },
          },
        },
        orderBy: [
          { priority: 'desc' },
          { createdAt: 'desc' },
        ],
        take: filters.limit,
        skip: filters.offset,
      });

      return alerts as AlertWithProduct[];
    } catch (error) {
      logger.error('‚ùå Error getting active alerts:', error);
      throw error;
    }
  }

  /**
   * Resuelve una alerta
   */
  async resolveAlert(alertId: string, resolvedBy: string): Promise<void> {
    try {
      await prisma.alert.update({
        where: { id: alertId },
        data: {
          isActive: false,
          resolvedAt: new Date(),
          resolvedBy,
        },
      });

      logger.info(`‚úÖ Alert resolved: ${alertId} by ${resolvedBy}`);
    } catch (error) {
      logger.error(`‚ùå Error resolving alert ${alertId}:`, error);
      throw error;
    }
  }

  /**
   * Obtiene alertas de un producto espec√≠fico
   */
  async getAlertsByProduct(productId: string): Promise<AlertWithProduct[]> {
    return this.getActiveAlerts({ productId });
  }

  /**
   * Limpia alertas resueltas antiguas
   */
  async cleanupOldAlerts(): Promise<number> {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - this.ALERT_CLEANUP_DAYS);

      const result = await prisma.alert.deleteMany({
        where: {
          isActive: false,
          resolvedAt: {
            lt: cutoffDate,
          },
        },
      });

      logger.info(`üßπ Cleaned up ${result.count} old alerts`);
      return result.count;
    } catch (error) {
      logger.error('‚ùå Error cleaning up old alerts:', error);
      throw error;
    }
  }

  /**
   * Actualiza m√©tricas de rendimiento del sistema de alertas
   */
  private async updatePerformanceMetrics(duration: number, productsChecked: number, alertsCreated: number): Promise<void> {
    try {
      const performanceThreshold = 30000; // 30 segundos
      
      if (duration > performanceThreshold) {
        await this.createAlert({
          type: AlertType.PERFORMANCE_WARNING,
          priority: AlertPriority.MEDIUM,
          title: 'Rendimiento del Sistema de Alertas',
          message: `La verificaci√≥n de stock tard√≥ ${Math.round(duration / 1000)} segundos (umbral: ${performanceThreshold / 1000}s)`,
          threshold: performanceThreshold,
          currentValue: duration,
          metadata: {
            productsChecked,
            alertsCreated,
            averageTimePerProduct: Math.round(duration / productsChecked),
            systemCheck: true,
            checkTimestamp: new Date().toISOString(),
          },
        });
      }
    } catch (error) {
      logger.error('‚ùå Error updating performance metrics:', error);
    }
  }

  /**
   * Obtiene estad√≠sticas del sistema de alertas
   */
  async getAlertStatistics(): Promise<{
    total: number;
    byType: Record<string, number>;
    byPriority: Record<string, number>;
    activeCount: number;
    resolvedToday: number;
  }> {
    try {
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const [total, byType, byPriority, activeCount, resolvedToday] = await Promise.all([
        prisma.alert.count(),
        prisma.alert.groupBy({
          by: ['type'],
          _count: { type: true },
        }),
        prisma.alert.groupBy({
          by: ['priority'],
          _count: { priority: true },
        }),
        prisma.alert.count({ where: { isActive: true } }),
        prisma.alert.count({
          where: {
            isActive: false,
            resolvedAt: { gte: today },
          },
        }),
      ]);

      const typeStats = Object.values(AlertType).reduce((acc, type) => {
        acc[type] = byType.find((item: any) => item.type === type)?._count.type || 0;
        return acc;
      }, {} as Record<string, number>);

      const priorityStats = Object.values(AlertPriority).reduce((acc, priority) => {
        acc[priority] = byPriority.find((item: any) => item.priority === priority)?._count.priority || 0;
        return acc;
      }, {} as Record<string, number>);

      return {
        total,
        byType: typeStats,
        byPriority: priorityStats,
        activeCount,
        resolvedToday,
      };
    } catch (error) {
      logger.error('‚ùå Error getting alert statistics:', error);
      throw error;
    }
  }
}

export const alertService = new AlertService();
